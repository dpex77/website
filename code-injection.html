<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Injection</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 0;
      background: #f4f4f9;
      color: #333;
    }
    header {
      background: #1e3a8a;
      color: #fff;
      padding: 1.5rem;
      text-align: center;
    }
    main {
      max-width: 900px;
      margin: auto;
      padding: 2rem;
      background: #fff;
    }
    h1, h2, h3 {
      color: #1e3a8a;
    }
    pre {
      background: #f4f4f4;
      padding: 1rem;
      border-radius: 6px;
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 0.6rem;
      text-align: left;
    }
    th {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <header>
    <h1>Code Injection</h1>
  </header>

  <main>
    <h2>1. Overview</h2>
    <p>
      Code injection would mean injecting the malicious code into the application so they get executed.
      Code injection usually runs with the context of the application itself. So, code injection typically
      compromises the application but may not directly affect the entire system. Code injection usually
      targets the application’s runtime environment (e.g., Python, PHP, Java, JavaScript).
    </p>

    <h2>2. Vulnerability from an Attacker Perspective</h2>
    <p>
      From an attacker’s point of view, this vulnerability is highly valuable because it provides a direct path
      to remote code execution (RCE). Once RCE is achieved, the attacker can perform a wide variety of malicious
      actions, such as:
    </p>
    <ul>
      <li><b>Arbitrary Command Execution</b> – run system-level commands (<code>rm -rf /</code>, <code>cat /etc/passwd</code>).</li>
      <li><b>File System Access</b> – read, modify, or delete sensitive files.</li>
      <li><b>Persistence and Lateral Movement</b> – create backdoors, install malware, move across the network.</li>
      <li><b>Privilege Escalation Opportunities</b> – if app runs as root/admin, exploit executes with same rights.</li>
      <li><b>Stealthy Abuse</b> – silently harvest secrets or manipulate logic.</li>
      <li><b>Exploitation of the Runtime Environment</b> – load arbitrary modules (<code>os</code>, <code>subprocess</code>, etc.).</li>
      <li><b>Business and Operational Impact</b> – DoS, breaches, legal issues, trust loss.</li>
    </ul>

    <p>
      An attacker needs to know what type of code application is using and craft malicious code.
      This is unlike command injection. The code injection exploits the language interpreter itself.
    </p>

    <h3>Attacker Discovery in Black-Box Testing</h3>
    <ul>
      <li><b>Error Messages</b> – verbose stack traces leak language info.</li>
      <li><b>Behavioral Clues</b> – math-like evaluation hints <code>eval</code>.</li>
      <li><b>Payload Probing</b> – test inputs like <code>1+1</code>, <code>"a"*5</code>, <code>__import__('os')</code>.</li>
      <li><b>Common Frameworks</b> – known stacks imply likely runtimes.</li>
    </ul>

    <p>Once identified, attackers craft payloads specific to that interpreter.</p>

    <h3>2.1 Attempts of an Attacker</h3>
    <pre>
user = input("Enter the first number: ")
user1 = input("enter the second number: ")
evaluated = eval(user) + eval(user1)
print(evaluated)
    </pre>
    <p>
      If attacker enters <code>__import__('os').system('rm -rf /')</code>,
      this executes destructive system commands.
    </p>

    <pre>
user_code = input("Enter Python code: ")
exec(user_code)
    </pre>
    <p>
      With <code>exec</code>, attacker could run:
      <code>__import__('os').system('rm -rf /')</code>
    </p>

    <h2>3. Vulnerability from a Defender Perspective</h2>
    <ul>
      <li>Never trust user input.</li>
      <li>Input validation &amp; sanitization (e.g., regex, whitelisting).</li>
      <li>Avoid using dynamic code execution (eval, exec, Function).</li>
      <li>Use contextual encoding (HTML, JS, SQL parameterization).</li>
      <li>Apply least privilege; don’t run apps as root.</li>
    </ul>

    <h3>3.1 Solutions of a Defender</h3>
    <h4>Avoid eval()</h4>
    <pre>
import ast
try:
    user = ast.literal_eval(input("Enter the first number: "))
    user1 = ast.literal_eval(input("Enter the second number: "))
    print(user + user1)
except Exception:
    print("Invalid input!")
    </pre>

    <h4>Avoid exec()</h4>
    <p>
      There is no safe equivalent. If needed, use <b>sandboxing</b> like
      RestrictedPython or isolated containers. Prefer task-specific libraries.
    </p>

    <h2>4. Extras: Difference from Command Injection</h2>
    <p>
      Command injection happens when user input is passed to system-level commands.
    </p>
    <pre>
import os
user_input = input("Enter filename: ")
os.system(f"cat {user_input}")
    </pre>
    <p>
      Attacker could type: <code>file.txt; rm -rf /</code>
    </p>

    <h3>Comparison Table</h3>
    <table>
      <tr>
        <th>Factor</th>
        <th>Command Injection</th>
        <th>Code Injection</th>
      </tr>
      <tr>
        <td>Target</td>
        <td>OS commands</td>
        <td>Application logic + sometimes OS</td>
      </tr>
      <tr>
        <td>Access to app internals</td>
        <td>None</td>
        <td>Full access to variables, memory, functions</td>
      </tr>
      <tr>
        <td>Potential impact</td>
        <td>High (files, network)</td>
        <td>Very High (app logic, secrets, system)</td>
      </tr>
      <tr>
        <td>Exploit complexity</td>
        <td>Easier</td>
        <td>Harder (requires language knowledge)</td>
      </tr>
      <tr>
        <td>Privileges dependency</td>
        <td>OS-level privileges</td>
        <td>App-level privileges (may escalate)</td>
      </tr>
    </table>
  </main>
</body>
</html>
