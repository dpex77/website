<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Injection</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; padding: 0; background: #fafafa; color: #222; }
    h1, h2, h3, h4 { color: #333; margin-top: 20px; }
    pre, code { background: #f4f4f4; padding: 8px; border-radius: 5px; display: block; white-space: pre-wrap; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #eee; }
  </style>
</head>
<body>
  <h1>Code Injection</h1>

  <h2>1. Overview:</h2>
  <p>Code injection would mean injecting the malicious code into the application so they get executed. Code injection usually runs with the context of the application itself. So, code injection typically compromises the application but may not directly affect the entire system. Code injection usually targets the application’s runtime environment (e.g., Python, PHP, Java, JavaScript).</p>

  <h2>2. Vulnerability from an Attacker Perspective</h2>
  <p>From an attacker’s point of view, this vulnerability is highly valuable because it provides a direct path to remote code execution (RCE). Once RCE is achieved, the attacker can perform a wide variety of malicious actions, such as:</p>

  <h3>Arbitrary Command Execution</h3>
  <p>The attacker can run system-level commands (<code>rm -rf /</code>, <code>cat /etc/passwd</code>, <code>netstat</code>, etc.). This effectively gives them control of the host system at the privilege level of the running application.</p>

  <h3>File System Access</h3>
  <p>Sensitive files such as <code>/etc/shadow</code>, database credentials, or API keys can be accessed and exfiltrated. The attacker can also modify or delete files, causing data corruption or system downtime.</p>

  <h3>Persistence and Lateral Movement</h3>
  <p>Attackers can create backdoors (e.g., writing a reverse shell script) or install malicious packages. Once persistence is established, they can attempt lateral movement to compromise other systems on the same network.</p>

  <h3>Privilege Escalation Opportunities</h3>
  <p>If the vulnerable application is running with elevated privileges (e.g., root or admin), the injected code executes at that same privilege level. This dramatically increases the impact, potentially leading to full system compromise.</p>

  <h3>Stealthy Abuse</h3>
  <p>Instead of outright destruction (like deleting files), a sophisticated attacker might silently harvest sensitive data (credentials, tokens, session IDs) or manipulate application logic to serve malicious purposes.</p>

  <h3>Exploitation of the Runtime Environment</h3>
  <p>Because code injection targets the interpreter itself (e.g., Python), the attacker can load arbitrary modules (<code>os</code>, <code>subprocess</code>, <code>socket</code>, <code>requests</code>) to extend their capabilities. Essentially, the attacker gains the same power as a developer with full interpreter access.</p>

  <h3>Business and Operational Impact</h3>
  <ul>
    <li>Service disruption (DoS by deleting critical files).</li>
    <li>Data breaches (regulatory/legal issues).</li>
    <li>Loss of trust and reputation for the application provider.</li>
  </ul>

  <p>An attacker needs to know what type of code application is using and craft malicious code. This is unlike command injection. The code injection exploits the language interpreter itself (Python in this case). It runs inside the application’s process, with the same privileges as the app and you can manipulate variables, import modules, access memory, etc.</p>

  <p>Here you are not limited to system commands — you can access internal data, override functions, manipulate files, open network connections, etc.</p>

  <h3>In black-box scenarios</h3>
  <p>Attackers often don’t know upfront which programming language or runtime the application uses. Unlike command injection (where system calls like <code>ls</code>, <code>dir</code>, or <code>whoami</code> are recognizable across environments), code injection requires guessing or inferring the underlying interpreter.</p>

  <p>Attackers can discover this through:</p>
  <ul>
    <li><b>Error Messages</b> – verbose messages like <code>NameError: name 'foobar' is not defined</code> point to Python.</li>
    <li><b>Behavioral Clues</b> – math evaluation hints at <code>eval</code>.</li>
    <li><b>Payload Probing</b> – inputs like <code>1+1</code>, <code>"a"*5</code>, <code>__import__('os')</code>.</li>
    <li><b>Common Frameworks</b> – Django, Flask → Python; Laravel → PHP.</li>
  </ul>

  <p>Once identified, payloads are crafted specific to that interpreter:</p>
  <ul>
    <li>Python: <code>__import__('os').system('id')</code></li>
    <li>PHP: <code>system('id')</code> or <code>eval($_GET['cmd']);</code></li>
    <li>Java: reflection or <code>Runtime.getRuntime().exec()</code></li>
  </ul>

  <h2>2.1 Attempts of an attacker:</h2>
  <p>A simplest example of code injection would be Python’s eval function:</p>

  <pre><code>user = input("Enter the first number: ")
user1 = input("enter the second number: ")

evaluated = eval(user) + eval(user1)
print(evaluated)

# Example run
Enter the first number: 10
enter the second number: 15
25

# Malicious run
Enter the first number: __import__('os').system('rm -rf /')
enter the second number:
</code></pre>

  <p>This would execute a system command that deletes all files.</p>

  <p>Another example:</p>
  <pre><code>Enter the first number: __import__('subprocess').getoutput('ls')
enter the second number:
</code></pre>

  <p>This lists files on the system. The attacker can read sensitive files (<code>open('/etc/passwd').read()</code>), run network commands, and install malware.</p>

  <p>Another example is Python’s exec function:</p>
  <pre><code>eval("2 + 3")   # returns 5

exec("for i in range(3): print(i)")
# prints 0 1 2

user_code = input("Enter Python code: ")
exec(user_code)

# Malicious payload
__import__('os').system('rm -rf /')
</code></pre>

  <h2>3. Vulnerability from a defender perspective:</h2>
  <ul>
    <li><b>Never trust user input</b></li>
    <li><b>Input validation</b>: enforce patterns (e.g., integers only).</li>
    <li><b>Input sanitization</b>: strip dangerous characters like <code>< > ' "</code>.</li>
    <li><b>Avoid dynamic execution</b>: no <code>eval()</code>, <code>exec()</code>, etc.</li>
    <li><b>Contextual encoding</b>: HTML, JavaScript, SQL parameterization, Base64, URL encoding.</li>
  </ul>

  <h3>3.1 Solutions of a defender:</h3>

  <h4>Avoid eval()</h4>
  <p>Why unsafe? It executes arbitrary expressions.</p>

  <pre><code>import ast

try:
    user = ast.literal_eval(input("Enter the first number: "))
    user1 = ast.literal_eval(input("Enter the second number: "))
    print(user + user1)
except Exception:
    print("Invalid input!")
</code></pre>

  <p>Other safer libraries: <b>decimal.Decimal</b>, <b>sympy</b>, <b>numexpr</b>.</p>

  <h4>Avoid exec()</h4>
  <p>Why unsafe? It can execute arbitrary statements. Use sandboxing or isolated interpreters if absolutely necessary (e.g., RestrictedPython, Docker).</p>

  <p>There’s no safe equivalent in the standard library.</p>

  <h2>4. Extras: Difference from Command Injection</h2>

  <pre><code>import os
user_input = input("Enter filename: ")
os.system(f"cat {user_input}")

# Attacker input
file.txt; rm -rf /
</code></pre>

  <p>Command injection requires only knowing the vulnerable input point; code injection requires knowing the language/runtime.</p>

  <table>
    <tr><th>Factor</th><th>Command Injection</th><th>Code Injection</th></tr>
    <tr><td>Target</td><td>OS commands</td><td>Application logic + OS</td></tr>
    <tr><td>Access to app internals</td><td>None</td><td>Full access to variables, memory, functions</td></tr>
    <tr><td>Potential impact</td><td>High</td><td>Very High</td></tr>
    <tr><td>Exploit complexity</td><td>Usually easier</td><td>Harder, needs knowledge of app</td></tr>
    <tr><td>Privileges dependency</td><td>OS-level</td><td>App-level (may escalate)</td></tr>
  </table>

  <table>
    <tr><th>Factor</th><th>Command Injection</th><th>Code Injection</th></tr>
    <tr><td>Knowledge needed</td><td>Minimal</td><td>Moderate — need language & context</td></tr>
    <tr><td>Exploitation complexity</td><td>Usually easier</td><td>Usually harder</td></tr>
    <tr><td>Impact</td><td>OS-level control</td><td>App logic + OS</td></tr>
    <tr><td>From IP only</td><td>High</td><td>Medium/Low</td></tr>
  </table>
</body>
</html>
