<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Format String Exploits</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f4f4 url('cloud.jpg') no-repeat top center;
    background-size: cover;
    padding: 20px;
    color: #111;
}

.card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(11,26,43,0.08);
    padding: 20px;
    margin-bottom: 20px;
    white-space: pre-wrap;
}

h2 {
    margin-top: 0;
}

code {
    background-color: #eee;
    padding: 2px 4px;
    border-radius: 4px;
}
</style>
</head>
<body>

<div class="card">
<h2>1. Overview:</h2>
Format string exploits occur when user-controlled input is passed directly as the format string to functions like <code>printf</code>, <code>fprintf</code>, <code>sprintf</code>, etc., without proper validation.  

Attackers can manipulate the format specifiers (like %x, %s, %n) to:
- Leak memory content
- Overwrite memory
- Hijack program control flow
</div>

<div class="card">
<h2>2. Vulnerability from an Attacker Perspective:</h2>
Attackers can:
- Read sensitive memory (stack or heap)
- Modify variables or function pointers
- Trigger crashes or Denial of Service (DoS)
- Potentially gain arbitrary code execution (if %n used)

Example techniques:
- <code>%x</code>: Print stack memory contents
- <code>%s</code>: Print memory as string
- <code>%n</code>: Write number of bytes printed to a variable
</div>

<div class="card">
<h2>2.1 Examples for Understanding:</h2>

<b>Example 1: Information Leak</b>
<code>
#include &lt;stdio.h&gt;

int main() {
    char input[100];
    printf("Enter your name: ");
    fgets(input, sizeof(input), stdin);

    printf(input); // Vulnerable!
    return 0;
}
</code>
Explanation: If attacker inputs: <code>%x %x %x %x</code>, program prints stack contents. Sensitive info like addresses or passwords could leak.

<b>Example 2: Overwriting Memory</b>
<code>
#include &lt;stdio.h&gt;

int secret = 0;

int main() {
    char input[100];
    printf("Enter value: ");
    fgets(input, sizeof(input), stdin);

    printf(input); // %n can overwrite 'secret'
    if(secret == 0x1234) {
        printf("Privilege escalated!\n");
    }
    return 0;
}
</code>
Explanation: Using <code>%n</code>, attacker can modify 'secret' variable and bypass program checks.

<b>Example 3: Safe Usage</b>
<code>
#include &lt;stdio.h&gt;

int main() {
    char input[100];
    printf("Enter your name: ");
    fgets(input, sizeof(input), stdin);

    printf("%s", input); // Safe: input is treated as data, not format
    return 0;
}
</code>
Explanation: Always specify the format string; never allow user input to control it.
</div>

<div class="card">
<h2>3. Vulnerability from a Defender Perspective:</h2>
Causes:
- Passing user input directly to printf-like functions
- Using outdated or unsafe libraries
- Lack of input validation
- Misunderstanding format string function behavior
</div>

<div class="card">
<h2>3.1 Solutions for a Defender:</h2>
- Never pass user input as the format string
- Always use fixed format specifiers: <code>printf("%s", user_input);</code>
- Enable compiler warnings (<code>-Wall</code>, <code>-Wformat-security</code>)
- Static code analysis to detect unsafe printf usage
- Educate developers about safe handling of user-controlled data
</div>

<div class="card">
<h2>4. Extras:</h2>
- %n specifier is particularly dangerous: writes number of bytes printed so far into memory
- Stack canary, ASLR, NX/DEP can reduce impact but not replace secure coding
- Real-world examples: WU-FTPD, some older Linux/Windows apps exploited via format string vulnerabilities
- Testing: Try inputting format specifiers (%x, %s, %n) in user fields and observe behavior (in safe lab environment)
</div>

</body>
</html>
