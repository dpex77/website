<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XSS (Cross-Site Scripting)</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f4f4 url('cloud.jpg') no-repeat top center;
    background-size: cover;
    padding: 20px;
    color: #111;
}

.card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(11,26,43,0.08);
    padding: 20px;
    margin-bottom: 20px;
    white-space: pre-wrap;
}

h2 {
    margin-top: 0;
}

code {
    background-color: #eee;
    padding: 2px 4px;
    border-radius: 4px;
}
</style>
</head>
<body>

<div class="card">
<h2>1. Overview:</h2>
Cross-Site Scripting (XSS) is a vulnerability that allows attackers to inject malicious scripts into web pages viewed by others. Once executed in a victim’s browser, these scripts can:

- Steal cookies or session tokens  
- Redirect users to malicious sites  
- Install malware  
- Perform phishing attacks
</div>

<div class="card">
<h2>2. Vulnerability from an Attacker Perspective:</h2>
XSS occurs when user input is not properly sanitized or encoded, allowing scripts such as:  
<code>&lt;script&gt;malicious_code&lt;/script&gt;</code> to run directly in the browser.
</div>

<div class="card">
<h2>2.1 Attempts of an Attacker:</h2>
Types of XSS:

<b>Reflected XSS</b>  
- The payload is embedded in a crafted link or request.  
- The server reflects this payload in its response without storing it.  
- Attackers trick victims into clicking the malicious link (via email, social media, phishing, etc.).  
- Key point: requires user interaction.

<b>Stored XSS</b>  
- The payload is saved on the server (e.g., in comment boxes, profile fields, forum posts, chat messages).  
- Example: <code>&lt;script&gt;alert('Hacked!')&lt;/script&gt;</code>  
- If unsanitized, every user who views the page triggers the script.  
- Key point: no attacker interaction is needed after the payload is stored—making this more dangerous.

<b>DOM-Based XSS</b>  
- The vulnerability exists entirely in client-side JavaScript.  
- The server may never see the malicious input.  
- Example: <code>document.getElementById('output').innerHTML = location.hash;</code>  
- When a user visits a URL with a malicious fragment (e.g., #<script>alert('XSS')</script>), the script executes in their browser.  
- Key point: purely client-side, triggered by unsafe DOM manipulation.
</div>

<div class="card">
<h2>3. Vulnerability from a Defender Perspective:</h2>
- Input validation: Reject or filter dangerous inputs (<, >, <script>).  
- Output encoding: Encode user data before rendering it in HTML, JavaScript, or URLs.  
- Content Security Policy (CSP): Restrict which scripts can execute on the page.  
- HTTP-only cookies: Prevent JavaScript from accessing sensitive session data.  
- Safe DOM handling: Avoid inserting untrusted data directly into innerHTML; use textContent or safe templating libraries.
</div>

<div class="card">
<h2>3.1 Solutions for a Defender:</h2>
- Validate all user inputs and sanitize outputs.  
- Apply strict CSP headers.  
- Encode outputs in the appropriate context (HTML, JS, URL).  
- Set HTTP-only flags for cookies to prevent access via JS.  
- Use safe templating methods to handle dynamic content.
</div>

<div class="card">
<h2>4. Extras:</h2>
- XSS is dangerous because it runs in the victim’s browser context.  
- Stored XSS is typically more severe than reflected XSS.  
- DOM-based XSS requires understanding of client-side JavaScript behavior.
</div>

</body>
</html>
